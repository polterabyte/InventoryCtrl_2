# План реализации системы управления заявками на товары

## Обзор проекта
Система управления инвентарем с расширенным функционалом заявок на товары, складскими операциями и отслеживанием товаров от заявки до установки.

## Структура задач

### 0.1 Критическая оптимизация: Добавление индексов для производительности
**Приоритет:** Критический  
**Зависимости:** Нет  
**Статус:** Ожидает

**Описание:** Добавить критические индексы для обеспечения производительности системы при росте данных.

**Детали:**
- Добавить индексы для `InventoryTransactions`:
  - `IX_InventoryTransaction_ProductId_Date` - для запросов по продуктам и датам
  - `IX_InventoryTransaction_Type_Date` - для фильтрации по типам транзакций
  - `IX_InventoryTransaction_WarehouseId_Type` - для запросов по складам
  - `IX_InventoryTransaction_UserId_Date` - для запросов пользователей
  - `IX_InventoryTransaction_Date_Type` - для отчетов по периодам

- Добавить индексы для `Products`:
  - `IX_Product_SKU` - для поиска по SKU
  - `IX_Product_CategoryId_IsActive` - для фильтрации по категориям
  - `IX_Product_ManufacturerId` - для запросов по производителям

- Добавить индексы для `AuditLogs`:
  - `IX_AuditLog_EntityName_EntityId` - для аудита изменений
  - `IX_AuditLog_UserId_Timestamp` - для истории пользователей

**Ожидаемый результат:** Улучшение производительности запросов в 10-50 раз.

**Стратегия тестирования:** Измерить производительность запросов до и после добавления индексов.

---

### 0.2 Критическая оптимизация: Устранение дублирования данных
**Приоритет:** Критический  
**Зависимости:** Нет  
**Статус:** Ожидает

**Описание:** Устранить дублирование данных между `Product.Quantity` и `ProductOnHandView.OnHandQty`.

**Детали:**
- Удалить поле `Quantity` из модели `Product`
- Создать вычисляемое свойство `CurrentQuantity` в `Product`
- Обновить все места использования `Product.Quantity` на `ProductOnHandView.OnHandQty`
- Добавить миграцию для удаления колонки `Quantity` из таблицы `Products`
- Обновить валидаторы и DTOs

**Ожидаемый результат:** Устранение риска рассинхронизации данных и упрощение архитектуры.

**Стратегия тестирования:** Проверить, что все запросы корректно работают с `ProductOnHandView` вместо `Product.Quantity`.

---

### 1. Создание моделей базы данных для системы заявок
**Приоритет:** Высокий  
**Зависимости:** Нет  
**Статус:** Ожидает

**Описание:** Революционная интеграция системы заявок с существующей транзакционной моделью через метаданные.

**Ключевое открытие:** Система заявок УЖЕ СУЩЕСТВУЕТ в виде Pending транзакций (ProductPendingView)!

**Детали:**
- Создать модели:
  - `Request` (метаданные для группировки Pending транзакций)
  - `RequestHistory` (аудит изменений заявок)
  - Расширить `InventoryTransaction` (добавить RequestId, UnitPrice, TotalPrice)

- Интеграция с существующими Views:
  - **ProductPendingView** = заявки на товары (Pending транзакции)
  - **ProductOnHandView** = остатки включая товары из заявок
  - **ProductInstalledView** = установки как результат выполнения заявок

- Workflow: Pending → Income → Install (естественный процесс)

**Стратегия тестирования:** Создать unit тесты для моделей, проверить интеграцию с существующими Views и транзакционной системой.

---

### 2. Создание миграций базы данных и оптимизация Views
**Приоритет:** Высокий  
**Зависимости:** Задача 1  
**Статус:** Ожидает

**Описание:** Создать и применить миграции Entity Framework для интеграции системы заявок с существующей транзакционной моделью, включая оптимизацию Views.

**Детали:**
- Создать миграции для:
  - Таблица `Requests` (метаданные заявок)
  - Таблица `RequestHistories` (аудит изменений заявок)
  - Расширение таблицы `InventoryTransactions` (добавить RequestId, UnitPrice, TotalPrice, RequestItemNotes)
  - Индексы для оптимизации запросов
  - Внешние ключи и ограничения

- **Оптимизация Views для производительности:**
  - Создать материализованные представления для ProductPendingView, ProductOnHandView, ProductInstalledView
  - Добавить триггеры для автоматического обновления материализованных представлений
  - Создать индексы для материализованных представлений
  - Добавить фильтрацию по датам для актуальных данных (например, последний год)

- **Критически важно:** Проверить совместимость с существующими Views:
  - ProductPendingView (оптимизирован через материализованное представление)
  - ProductOnHandView (оптимизирован через материализованное представление)
  - ProductInstalledView (оптимизирован через материализованное представление)

**Ожидаемый результат:** Улучшение производительности Views в 5-20 раз через материализованные представления.

**Стратегия тестирования:** Применить миграции на тестовой базе данных, проверить целостность данных, производительность запросов и совместимость с оптимизированными Views.

---

### 3. Создание API контроллера для управления заявками
**Приоритет:** Высокий  
**Зависимости:** Задача 2  
**Статус:** Ожидает

**Описание:** Реализовать REST API контроллер для управления заявками с интеграцией в существующую транзакционную систему.

**Детали:**
- Создать `RequestController` с методами:
  - `GET /api/requests` - получение списка заявок с фильтрацией
  - `GET /api/requests/{id}` - получение заявки по ID с транзакциями
  - `POST /api/requests` - создание новой заявки (создает Pending транзакции)
  - `PUT /api/requests/{id}` - обновление заявки
  - `DELETE /api/requests/{id}` - отмена заявки
  - `GET /api/requests/{id}/history` - получение истории заявки
  - `POST /api/requests/{id}/status` - изменение статуса заявки
  - `POST /api/requests/{id}/items` - добавление позиций (создание Pending транзакций)
  - `POST /api/requests/{id}/receive` - поступление товаров (изменение Pending → Income)
  - `POST /api/requests/{id}/install` - установка товаров (создание Install транзакций)

- Интеграция с существующими Views:
  - Использование ProductPendingView для получения заявок
  - Использование ProductOnHandView для проверки остатков
  - Использование ProductInstalledView для отслеживания установок

**Стратегия тестирования:** Создать интеграционные тесты для всех endpoints, проверить интеграцию с транзакционной системой и Views.

---

### 4. Реализация сервиса для управления заявками
**Приоритет:** Высокий  
**Зависимости:** Задача 3  
**Статус:** Ожидает

**Описание:** Создать бизнес-логику для обработки заявок с интеграцией в существующую транзакционную систему.

**Детали:**
- Создать `RequestService` с методами:
  - `CreateRequestAsync` - создание заявки (создает Pending транзакции)
  - `UpdateRequestStatusAsync` - изменение статуса заявки
  - `CancelRequestAsync` - отмена заявки
  - `GetRequestsByUserAsync` - получение заявок пользователя (через ProductPendingView)
  - `GetRequestsByWarehouseAsync` - получение заявок по складу
  - `AddRequestItemAsync` - добавление позиции (создание Pending транзакции)
  - `ProcessRequestItemReceivedAsync` - обработка поступления (Pending → Income)
  - `ProcessRequestItemInstalledAsync` - обработка установки (создание Install транзакции)

- Интеграция с транзакционной системой:
  - Использование существующих типов транзакций (Pending, Income, Install)
  - Работа с ProductPendingView для получения заявок
  - Работа с ProductOnHandView для проверки остатков
  - Работа с ProductInstalledView для отслеживания установок

**Стратегия тестирования:** Создать unit тесты для всех методов сервиса, проверить интеграцию с транзакционной системой и Views.

---

### 5. Расширение API для управления локациями (если необходимо)
**Приоритет:** Низкий  
**Зависимости:** Задача 2  
**Статус:** Ожидает

**Описание:** Расширить существующий API для управления локациями, если потребуется дополнительная функциональность для системы заявок.

**Детали:**
- Проанализировать существующую модель `Location`:
  - Проверить, достаточно ли существующей функциональности
  - Определить, нужны ли дополнительные поля для QR-кодов
  - Оценить необходимость расширения API

- Если необходимо, расширить `LocationController`:
  - `GET /api/locations/{id}/qr-code` - получение QR-кода (если добавим поле)
  - `POST /api/locations/scan` - сканирование QR-кода (если добавим поле)
  - Дополнительные методы для интеграции с заявками

**Стратегия тестирования:** Протестировать существующую функциональность локаций, определить необходимость расширения.

---

### 6. Реализация страниц Blazor для управления заявками
**Приоритет:** Высокий  
**Зависимости:** Задача 4  
**Статус:** Ожидает

**Описание:** Создать пользовательский интерфейс для управления заявками с интеграцией в существующую транзакционную систему.

**Детали:**
- Создать страницы:
  - `Requests/Index.razor` - список заявок с фильтрацией (использует ProductPendingView)
  - `Requests/Create.razor` - создание новой заявки
  - `Requests/Details.razor` - детальный просмотр заявки с транзакциями
  - `Requests/Edit.razor` - редактирование заявки
  - `Requests/History.razor` - история изменений заявки
  - `Requests/Receive.razor` - поступление товаров (Pending → Income)
  - `Requests/Install.razor` - установка товаров (создание Install транзакций)

- Компоненты:
  - `RequestCard.razor` - карточка заявки
  - `RequestForm.razor` - форма создания/редактирования
  - `RequestStatusBadge.razor` - индикатор статуса
  - `RequestTimeline.razor` - временная линия заявки
  - `TransactionList.razor` - список транзакций заявки
  - `PendingItemsList.razor` - список Pending позиций
  - `ReceivedItemsList.razor` - список поступивших товаров
  - `InstalledItemsList.razor` - список установленных товаров

- Интеграция с Views:
  - Использование ProductPendingView для отображения заявок
  - Использование ProductOnHandView для проверки остатков
  - Использование ProductInstalledView для отслеживания установок

**Стратегия тестирования:** Создать компонентные тесты для всех страниц и компонентов, проверить интеграцию с Views и транзакционной системой.

---

### 7. Расширение страниц для управления локациями (если необходимо)
**Приоритет:** Низкий  
**Зависимости:** Задача 5  
**Статус:** Ожидает

**Описание:** Расширить существующие страницы для управления локациями, если потребуется дополнительная функциональность для системы заявок.

**Детали:**
- Проанализировать существующие страницы локаций:
  - Проверить, достаточно ли существующей функциональности
  - Определить, нужны ли дополнительные страницы для QR-кодов
  - Оценить необходимость интеграции с заявками

- Если необходимо, расширить существующие страницы:
  - Добавить QR-код функциональность (если добавим поле)
  - Интегрировать с системой заявок
  - Добавить сканер QR-кодов (если добавим поле)

**Стратегия тестирования:** Протестировать существующую функциональность локаций, определить необходимость расширения.

---

### 8. Интеграция SignalR уведомлений для заявок
**Приоритет:** Средний  
**Зависимости:** Задача 4  
**Статус:** Ожидает

**Описание:** Добавить реальные уведомления о изменениях статусов заявок через SignalR с интеграцией в транзакционную систему.

**Детали:**
- Расширить существующий `NotificationHub`:
  - Добавить группы для пользователей по ролям
  - Создать методы для уведомлений о заявках:
    - `RequestCreated` - создание заявки
    - `RequestStatusChanged` - изменение статуса заявки
    - `RequestCancelled` - отмена заявки
    - `RequestItemAdded` - добавление позиции (создание Pending транзакции)
    - `RequestItemReceived` - поступление товара (Pending → Income)
    - `RequestItemInstalled` - установка товара (создание Install транзакции)

- Интеграция с транзакционной системой:
  - Уведомления при изменении типов транзакций
  - Уведомления при работе с ProductPendingView
  - Уведомления при работе с ProductOnHandView
  - Уведомления при работе с ProductInstalledView

- Обновить клиентскую часть:
  - Подписка на уведомления о заявках
  - Отображение уведомлений в реальном времени
  - Обновление списков заявок без перезагрузки

**Стратегия тестирования:** Создать тесты для SignalR уведомлений, проверить интеграцию с транзакционной системой и Views.

---

### 9. Реализация ролевой модели доступа для заявок
**Приоритет:** Высокий  
**Зависимости:** Задача 3  
**Статус:** Ожидает

**Описание:** Настроить права доступа для разных ролей пользователей в системе заявок с интеграцией в транзакционную систему.

**Детали:**
- Настроить авторизацию:
  - **Admin:** полный доступ ко всем заявкам и операциям
  - **Manager:** создание, редактирование, отмена заявок; складские операции (Pending → Income → Install)
  - **User:** только просмотр заявок и формирование отчетов

- Реализовать:
  - Атрибуты авторизации на контроллерах
  - Проверку прав в сервисах
  - Фильтрацию данных по ролям через Views
  - Аудит доступа

- Интеграция с транзакционной системой:
  - Права на создание Pending транзакций
  - Права на изменение типов транзакций (Pending → Income → Install)
  - Права на просмотр ProductPendingView, ProductOnHandView, ProductInstalledView
  - Безопасность API endpoints для работы с транзакциями

**Стратегия тестирования:** Создать тесты авторизации для всех ролей, проверить ограничения доступа к Views и транзакционной системе.

---

### 10. Создание отчетов и аналитики для заявок
**Приоритет:** Низкий  
**Зависимости:** Задача 6  
**Статус:** Ожидает

**Описание:** Реализовать систему отчетов для анализа заявок и складских операций с использованием существующих Views.

**Детали:**
- Создать отчеты на основе существующих Views:
  - **ProductPendingView** - статистика заявок по периодам
  - **ProductOnHandView** - анализ остатков и поступлений
  - **ProductInstalledView** - анализ установок и эффективности
  - Комбинированные отчеты по всему циклу: Pending → Income → Install

- Страницы отчетов:
  - `Reports/Requests.razor` - отчеты по заявкам (ProductPendingView)
  - `Reports/Warehouse.razor` - отчеты по складам (ProductOnHandView)
  - `Reports/Performance.razor` - аналитика производительности (ProductInstalledView)
  - `Reports/FullCycle.razor` - полный цикл заявок

- Интеграция с транзакционной системой:
  - Автоматические отчеты на основе транзакций
  - Анализ эффективности выполнения заявок
  - Отслеживание времени выполнения (Pending → Income → Install)

- Включить:
  - Экспорт в Excel/PDF
  - Интерактивные графики
  - Фильтрацию и группировку данных

**Стратегия тестирования:** Протестировать генерацию отчетов на основе Views, проверить корректность данных и экспорт.

---

## Диаграмма зависимостей

```
0.1. Критическая оптимизация: Добавление индексов
0.2. Критическая оптимизация: Устранение дублирования данных
   ↓
1. Создание моделей БД (Request, RequestHistory, расширение InventoryTransaction)
   ↓
2. Создание миграций БД + оптимизация Views (материализованные представления)
   ↓
3. API контроллер заявок ← 9. Ролевая модель
   ↓
4. Сервис управления заявками (интеграция с транзакционной системой)
   ↓
6. Blazor страницы заявок ← 8. SignalR уведомления
   ↓
10. Отчеты и аналитика (на основе оптимизированных Views)

5. Расширение API локаций (если необходимо)
   ↓
7. Расширение страниц локаций (если необходимо)
```

## Ключевые интеграции

- **ProductPendingView** = заявки на товары (Pending транзакции)
- **ProductOnHandView** = остатки включая товары из заявок
- **ProductInstalledView** = установки как результат выполнения заявок
- **Workflow**: Pending → Income → Install (естественный процесс)

## Критерии успеха

- ✅ **Критическая оптимизация производительности** через индексы и материализованные представления
- ✅ **Устранение дублирования данных** между Product.Quantity и ProductOnHandView
- ✅ **Революционная интеграция** с существующей транзакционной системой
- ✅ **Полное отслеживание** товара от заявки до установки (Pending → Income → Install)
- ✅ **Автоматическая отчетность** через оптимизированные Views (ProductPendingView, ProductOnHandView, ProductInstalledView)
- ✅ **Нулевое влияние** на существующую функциональность
- ✅ **Естественный workflow** без принуждения
- ✅ **Удобный интерфейс** для всех ролей пользователей
- ✅ **Автоматические уведомления** о изменениях статусов через SignalR
- ✅ **Возможность отмены** заявок на любом этапе

## Следующие шаги

1. **Начать с критических оптимизаций 0.1 и 0.2** - индексы и устранение дублирования данных
2. **Перейти к задаче 1** - создание моделей базы данных с революционной интеграцией
3. **Последовательно выполнять задачи** согласно зависимостям
4. **Тестировать каждый этап** перед переходом к следующему, особенно интеграцию с Views
5. **Документировать изменения** и обновлять API документацию
6. **Проверять совместимость** с существующими Views на каждом этапе
7. **Тестировать интеграцию** с транзакционной системой
8. **Измерять производительность** на каждом этапе оптимизации

## Революционные преимущества нового подхода

- **Критическая оптимизация производительности** через индексы и материализованные представления
- **Система заявок УЖЕ СУЩЕСТВУЕТ** в виде Pending транзакций
- **ProductPendingView автоматически показывает** все заявки
- **Нулевое влияние** на существующую функциональность
- **Автоматическая отчетность** через оптимизированные Views
- **Естественный workflow** без принуждения
- **Элегантная интеграция** с минимальными изменениями
- **Готовность к масштабированию** при росте данных
