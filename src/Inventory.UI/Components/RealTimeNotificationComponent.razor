@using Microsoft.JSInterop
@using Inventory.Shared.DTOs
@using System.Text.Json
@using Microsoft.Extensions.Logging
@using Blazored.LocalStorage
@using Microsoft.AspNetCore.Components.Authorization
@inject IJSRuntime JSRuntime
@inject ILogger<RealTimeNotificationComponent> Logger
@inject ILocalStorageService LocalStorage
@inject AuthenticationStateProvider AuthStateProvider

<div class="real-time-notifications">
    @if (IsConnected)
    {
        <div class="connection-status connected">
            <i class="fas fa-circle text-success"></i>
            <span>Real-time notifications active</span>
        </div>
    }
    else if (IsReconnecting)
    {
        <div class="connection-status reconnecting">
            <i class="fas fa-circle text-warning"></i>
            <span>Reconnecting...</span>
        </div>
    }
    else
    {
        @if (ShowSignInBanner && string.IsNullOrEmpty(accessToken))
        {
            <div class="connection-status disconnected sign-in-banner">
                <i class="fas fa-circle text-danger"></i>
                <span>Sign in to enable notifications</span>
                <button class="btn-close ms-auto" @onclick="DismissSignInBanner" title="Dismiss"></button>
            </div>
        }
        else if (!string.IsNullOrEmpty(accessToken))
        {
            <div class="connection-status disconnected">
                <i class="fas fa-circle text-danger"></i>
                <span>Real-time notifications offline</span>
            </div>
        }
    }

    @if (ShowNotifications)
    {
        <div class="notifications-container">
            @foreach (var notification in Notifications.Take(MaxVisibleNotifications))
            {
                <div class="notification-item @GetNotificationClass(notification.Type)" 
                     data-notification-id="@notification.Id">
                    <div class="notification-content">
                        <div class="notification-header">
                            <h6 class="notification-title">@notification.Title</h6>
                            <button class="btn-close" @onclick="() => DismissNotification(notification.Id)"></button>
                        </div>
                        <p class="notification-message">@notification.Message</p>
                        @if (!string.IsNullOrEmpty(notification.ActionUrl) && !string.IsNullOrEmpty(notification.ActionText))
                        {
                            <a href="@notification.ActionUrl" class="btn btn-sm btn-outline-primary notification-action">
                                @notification.ActionText
                            </a>
                        }
                    </div>
                    <div class="notification-meta">
                        <small class="text-muted">@notification.CreatedAt.ToString("HH:mm")</small>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public bool ShowNotifications { get; set; } = true;
    [Parameter] public int MaxVisibleNotifications { get; set; } = 5;
    [Parameter] public int AutoDismissDelay { get; set; } = 5000; // 5 seconds
    [Parameter] public EventCallback<NotificationDto> OnNotificationReceived { get; set; }
    [Parameter] public EventCallback<string> OnConnectionStateChanged { get; set; }

    private List<NotificationDto> Notifications { get; set; } = new();
    private bool IsConnected { get; set; } = false;
    private bool IsReconnecting { get; set; } = false;
    private string ConnectionState { get; set; } = "Disconnected";
    private string? accessToken { get; set; }
    private DotNetObjectReference<RealTimeNotificationComponent>? dotNetRef;
    private bool ShowSignInBanner { get; set; } = true;
    private Timer? signInBannerTimer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation("RealTimeNotificationComponent first render");
            dotNetRef = DotNetObjectReference.Create(this);
            // Wait for JavaScript services to be available
            await WaitForJavaScriptServices();
            await InitializeSignalR();
            
            // Check authentication state and manage banner
            await CheckAuthenticationStateAndManageBanner();
        }
    }

    private async Task WaitForJavaScriptServices()
    {
        var maxAttempts = 10;
        var attempt = 0;
        
        while (attempt < maxAttempts)
        {
            try
            {
                // Check if all required functions are available
                var isGetApiBaseUrlAvailable = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.getApiBaseUrl === 'function'");
                var isSignalRServiceAvailable = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.signalRNotificationService === 'object'");
                var isInitializeFunctionAvailable = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.initializeSignalRConnection === 'function'");
                
                if (isGetApiBaseUrlAvailable && isSignalRServiceAvailable && isInitializeFunctionAvailable)
                {
                    Logger.LogInformation("All JavaScript services are available");
                    return;
                }
                
                Logger.LogInformation("Waiting for JavaScript services... Attempt {Attempt}/{MaxAttempts}", attempt + 1, maxAttempts);
                await Task.Delay(200); // Wait 200ms before next attempt
                attempt++;
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Error checking JavaScript services availability");
                await Task.Delay(200);
                attempt++;
            }
        }
        
        Logger.LogWarning("JavaScript services not available after {MaxAttempts} attempts", maxAttempts);
    }

    private async Task InitializeSignalR()
    {
        try
        {
            // Get API base URL from JavaScript
            var apiBaseUrl = await JSRuntime.InvokeAsync<string>("getApiBaseUrl");
            
            // Get access token from LocalStorage (same key as CustomAuthenticationStateProvider uses)
            accessToken = await LocalStorage.GetItemAsStringAsync("authToken");

            if (string.IsNullOrEmpty(apiBaseUrl) || string.IsNullOrEmpty(accessToken))
            {
                Logger.LogWarning("API base URL or access token not available for SignalR connection. ApiBaseUrl: {ApiBaseUrl}, HasToken: {HasToken}", 
                    apiBaseUrl, !string.IsNullOrEmpty(accessToken));
                
                // If no token, ensure banner is shown
                if (string.IsNullOrEmpty(accessToken))
                {
                    ShowSignInBanner = true;
                    StartSignInBannerTimer();
                }
                
                StateHasChanged(); // Update UI to show appropriate message
                return;
            }

            // Initialize SignalR connection
            var success = await JSRuntime.InvokeAsync<bool>("initializeSignalRConnection", apiBaseUrl, accessToken, dotNetRef);
            
            if (success)
            {
                Logger.LogInformation("SignalR connection initialized successfully");
            }
            else
            {
                Logger.LogError("Failed to initialize SignalR connection");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing SignalR connection");
        }
    }

    // Listen for authentication state changes to reconnect SignalR
    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("RealTimeNotificationComponent initialized");
        AuthStateProvider.AuthenticationStateChanged += OnAuthenticationStateChanged;
        
        // Initial check of authentication state
        await CheckAuthenticationStateAndManageBanner();
    }

    private async void OnAuthenticationStateChanged(Task<AuthenticationState> authStateTask)
    {
        var authState = await authStateTask;
        var isAuthenticated = authState.User.Identity?.IsAuthenticated == true;
        
        if (isAuthenticated)
        {
            // User logged in, hide sign-in banner and try to initialize SignalR
            ShowSignInBanner = false;
            StopSignInBannerTimer();
            await InitializeSignalR();
        }
        else
        {
            // User logged out, disconnect SignalR and show sign-in banner
            await DisconnectSignalR();
            ShowSignInBanner = true;
            StartSignInBannerTimer();
        }
        
        StateHasChanged();
    }

    private async Task DisconnectSignalR()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("disconnectSignalR");
            IsConnected = false;
            ConnectionState = "Disconnected";
            accessToken = null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disconnecting SignalR");
        }
    }

    [JSInvokable]
    public void OnNotificationReceivedJS(NotificationDto notification)
    {
        try
        {
            Notifications.Insert(0, notification);
            
            // Keep only the maximum number of notifications
            if (Notifications.Count > MaxVisibleNotifications * 2)
            {
                Notifications = Notifications.Take(MaxVisibleNotifications * 2).ToList();
            }

            // Auto-dismiss after delay
            if (AutoDismissDelay > 0)
            {
                _ = Task.Delay(AutoDismissDelay).ContinueWith(_ => 
                {
                    InvokeAsync(() => DismissNotification(notification.Id));
                });
            }

            // Notify parent component
            OnNotificationReceived.InvokeAsync(notification);
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling received notification");
        }
    }

    [JSInvokable]
    public void OnConnectionStateChangedJS(string state, string? error = null)
    {
        try
        {
            ConnectionState = state;
            IsConnected = state == "Connected";
            IsReconnecting = state == "Reconnecting";
            
            OnConnectionStateChanged.InvokeAsync(state);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling connection state change");
        }
    }

    private void DismissNotification(int notificationId)
    {
        Notifications.RemoveAll(n => n.Id == notificationId);
        StateHasChanged();
    }

    private void DismissSignInBanner()
    {
        Logger.LogInformation("Sign-in banner dismissed by user");
        ShowSignInBanner = false;
        StopSignInBannerTimer();
        StateHasChanged();
    }

    private void StartSignInBannerTimer()
    {
        StopSignInBannerTimer();
        Logger.LogInformation("Starting sign-in banner auto-dismiss timer (10 seconds)");
        signInBannerTimer = new Timer(async _ =>
        {
            await InvokeAsync(() =>
            {
                Logger.LogInformation("Sign-in banner auto-dismissed after 10 seconds");
                ShowSignInBanner = false;
                StateHasChanged();
            });
        }, null, TimeSpan.FromSeconds(10), Timeout.InfiniteTimeSpan);
    }

    private void StopSignInBannerTimer()
    {
        signInBannerTimer?.Dispose();
        signInBannerTimer = null;
    }

    private async Task CheckAuthenticationStateAndManageBanner()
    {
        try
        {
            // Get current authentication state
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var isAuthenticated = authState.User.Identity?.IsAuthenticated == true;
            
            Logger.LogInformation("Authentication state check: IsAuthenticated={IsAuthenticated}, UserName={UserName}", 
                isAuthenticated, authState.User.Identity?.Name);
            
            if (isAuthenticated)
            {
                // User is authenticated, hide banner
                Logger.LogInformation("User is authenticated, hiding sign-in banner");
                ShowSignInBanner = false;
                StopSignInBannerTimer();
            }
            else
            {
                // User is not authenticated, show banner with timer
                Logger.LogInformation("User is not authenticated, showing sign-in banner");
                ShowSignInBanner = true;
                StartSignInBannerTimer();
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking authentication state");
            // Default to showing banner if there's an error
            ShowSignInBanner = true;
            StartSignInBannerTimer();
            StateHasChanged();
        }
    }

    private string GetNotificationClass(string type)
    {
        return type?.ToUpper() switch
        {
            "SUCCESS" => "notification-success",
            "WARNING" => "notification-warning",
            "ERROR" => "notification-error",
            "INFO" => "notification-info",
            _ => "notification-info"
        };
    }

    public async Task SubscribeToNotificationType(string notificationType)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("subscribeToNotificationType", notificationType);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error subscribing to notification type: {NotificationType}", notificationType);
        }
    }

    public async Task UnsubscribeFromNotificationType(string notificationType)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("unsubscribeFromNotificationType", notificationType);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error unsubscribing from notification type: {NotificationType}", notificationType);
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            AuthStateProvider.AuthenticationStateChanged -= OnAuthenticationStateChanged;
            StopSignInBannerTimer();
            await JSRuntime.InvokeVoidAsync("disconnectSignalR");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disconnecting SignalR");
        }
        finally
        {
            dotNetRef?.Dispose();
        }
    }
}
